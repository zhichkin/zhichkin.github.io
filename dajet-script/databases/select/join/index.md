## DaJet Script

[SELECT](https://github.com/zhichkin/dajet/tree/main/doc/dajet-script/databases/select/README.md)

### Оператор JOIN

- [Соединение обычных таблиц между собой](#соединение-обычных-таблиц)
- [Соединение обычной таблицы и табличного выражения](#соединение-обычной-таблицы-и-табличного-выражения)
- [Использование общего табличного выражения в соединении](#использование-общего-табличного-выражения-в-соединении)

Табличный оператор **JOIN** реализован DaJet Script аналогично стандарту ```SQL```. Однако синтаксис DaJet Script более строг и требует явного указания вида соединения перед ключевым словом **JOIN** - значение по умолчанию не предусмотрено. В качестве табличного источника оператор **JOIN** может использовать идентификаторы таблиц базы данных (их имена) или табличные выражения - запрос **SELECT**, заключённый в круглые скобки. Кроме этого могут также использоваться общие табличные выражения, описанные в соответствующем разделе документации.

Поддерживаются следующие виды соединений:
- FULL (полное соединение)
- LEFT (левое соединение)
- RIGHT (правое соединение)
- INNER (внутреннее соединение)

> Более подробно о видах соединений табличного оператора **JOIN** можно почитать в документации по стандартному SQL, например, для Microsoft SQL Server или PostgreSQL.

#### Соединение обычных таблиц

В данном примере в качестве левого операнда табличного оператора **JOIN** используется таблица ```РегистрНакопления.ЗапасыНаСкладах```, а правого операнда - ```Справочник.Номенклатура```. Выполняется внутреннее соединение на равенство измерения ```Номенклатура``` первого операнда (синоним ```Запасы```) и ключевому реквизиту ```Ссылка``` второго (синоним ```Товары```): ```Запасы.Номенклатура = Товары.Ссылка```.

```SQL
DECLARE @table   array
DECLARE @company entity

USE 'mssql://zhichkin/unf'

   -- Запрос скалярного значения (entity)
   SELECT Ссылка INTO @company
     FROM Справочник.Организации
    WHERE Код = '00-000001'

   -- Запрос набора записей (array)
    SELECT TOP 10
           Товар      = Товары.Наименование
         , Количество = SUM(CASE WHEN Запасы.ВидДвижения = 0
                                THEN  Запасы.Количество -- Приход
                                ELSE -Запасы.Количество -- Расход
                           END)
      INTO @table
      FROM РегистрНакопления.ЗапасыНаСкладах AS Запасы
INNER JOIN Справочник.Номенклатура           AS Товары
        ON Запасы.Организация  = @company
       AND Запасы.Номенклатура = Товары.Ссылка
     GROUP BY Товары.Наименование
    HAVING SUM(CASE WHEN Запасы.ВидДвижения = 0
                   THEN  Запасы.Количество
                   ELSE -Запасы.Количество END) > 0
     ORDER BY Товары.Наименование ASC

END

IF @table = NULL
THEN RETURN 'Нет данных'
ELSE RETURN @table
END
```

[Наверх](#оператор-join)

#### Соединение обычной таблицы и табличного выражения

Данный пример аналогичен по сути предыдущему за исключением того, что теперь левый операнд табличного оператора **JOIN** это ```Справочник.Номенклатура```, а правый - табличное выражение, которое предварительно формирует выборку из таблицы ```РегистрНакопления.ЗапасыНаСкладах``` и выполняет соответствующие вычисления для получения остатков. Результат выполнения обоих, этого и предыдущего, запросов будет идентичным.

```SQL
DECLARE @table   array
DECLARE @company entity

USE 'mssql://zhichkin/unf'

   -- Запрос скалярного значения (entity)
   SELECT Ссылка INTO @company
     FROM Справочник.Организации
    WHERE Код = '00-000001'

   -- Запрос набора записей (array)
    SELECT TOP 10
           Товар = Товары.Наименование
         , Остаток = Запасы.Количество
      INTO @table
      FROM Справочник.Номенклатура AS Товары      
INNER JOIN (SELECT Номенклатура
                 , Количество = SUM(CASE WHEN ВидДвижения = 0
                                         THEN  Количество -- Приход
                                         ELSE -Количество -- Расход
                                    END)
              FROM РегистрНакопления.ЗапасыНаСкладах
             WHERE Организация  = @company       
             GROUP BY Номенклатура
            HAVING SUM(CASE WHEN ВидДвижения = 0
                            THEN  Количество
                            ELSE -Количество END) > 0) AS Запасы

        ON Товары.Ссылка = Запасы.Номенклатура

     ORDER BY Товары.Наименование ASC

END

IF @table = NULL
THEN RETURN 'Нет данных'
ELSE RETURN @table
END
```

[Наверх](#оператор-join)

#### Использование общего табличного выражения в соединении

Данный пример также аналогичен предыдущим двум за исключением того, что теперь левый операнд табличного оператора **JOIN** это общее табличное выражение ```Запасы```, которое вычисляется при помощи выполнения запроса к таблице ```РегистрНакопления.ЗапасыНаСкладах```, а правый операнд - ```Справочник.Номенклатура```. Результат выполнения этого запроса также будет идентичным предыдущим двум.

```SQL
DECLARE @table   array
DECLARE @company entity

USE 'mssql://zhichkin/unf'

   -- Запрос скалярного значения (entity)
   SELECT Ссылка INTO @company
     FROM Справочник.Организации
    WHERE Код = '00-000001'

   -- Запрос набора записей (array)
   CREATE COMPUTED TABLE Запасы AS
   (
      SELECT Номенклатура
           , Количество = SUM(CASE WHEN ВидДвижения = 0
                                   THEN  Количество -- Приход
                                   ELSE -Количество -- Расход
                              END)
        FROM РегистрНакопления.ЗапасыНаСкладах
       WHERE Организация  = @company       
       GROUP BY Номенклатура
      HAVING SUM(CASE WHEN ВидДвижения = 0
                      THEN  Количество
                      ELSE -Количество END) > 0
   )
   SELECT TOP 10
          Товар = Товары.Наименование
        , Остаток = Запасы.Количество
     INTO @table
     FROM Запасы
    INNER JOIN Справочник.Номенклатура AS Товары
       ON Запасы.Номенклатура = Товары.Ссылка
    ORDER BY Товары.Наименование ASC

END

IF @table = NULL
THEN RETURN 'Нет данных'
ELSE RETURN @table
END
```

[Наверх](#оператор-join)
